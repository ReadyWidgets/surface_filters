import "awful"
import "gears"
import "wibox"
import "beautiful"

import "surface_filters.surface_filters"

from "lgi" import Gdk, cairo

---@generic T1
--- Check if a given parameter is of the expected type, otherwise throw an error
---@param func_name string string The name of the function the parameter belongs to
---@param position integer The integer position of the parameter
---@param wanted_type `T1` The type that the parameter should have
---@param value T1 The actual parameter itself
const assert_param_type = (func_name, position, wanted_type, value) ->
	const value_type = type(value)

	assert((value_type == wanted_type), "Wrong type of parameter #%d passed to '%s' (expected %s, got %s)"::format(position, func_name, wanted_type, value_type))

------------------------------------------------------

--- The functions in this block are wrappers around the native C functions exposed
--- through `surface_filters.so`. At the end, they are also bound as methods of
--- `cairo.ImageSurface`, which makes them more convenient to access.

--- Create a blurred copy of a `cairo.ImageSurface`
---@param input_surface cairo.ImageSurface The surface you wish to create a blurred copy of
---@param radius integer The blur radius; must be positive (higher = more blurry)
---@return cairo.ImageSurface
export cairo_image_surface_create_blurred = (input_surface, radius) ->
	assert_param_type("cairo_image_surface_create_blurred", 1, "userdata", input_surface)
	assert_param_type("cairo_image_surface_create_blurred", 2, "number", radius)

	assert(radius > 0, "You must provide a blur radius greater than 0!")

	cairo.Surface(surface_filters.cairo_image_surface_create_blurred(input_surface._native, radius))

--- Create a shadow copy of a `cairo.ImageSurface`
---@param input_surface cairo.ImageSurface The surface you wish to create a shadow copy of
---@param radius integer The shadow radius; must be positive (higher = more blurry)
---@return cairo.ImageSurface
export cairo_image_surface_create_shadow = (input_surface, radius) ->
	assert_param_type("cairo_image_surface_create_shadow", 1, "userdata", input_surface)
	assert_param_type("cairo_image_surface_create_shadow", 2, "number", radius)

	assert(radius > 0, "You must provide a shadow radius greater than 0!")

	cairo.Surface(surface_filters.cairo_image_surface_create_shadow(input_surface._native, radius))

cairo.ImageSurface.create_blurred = cairo_image_surface_create_blurred
cairo.ImageSurface.create_shadow  = cairo_image_surface_create_shadow

------------------------------------------------------

--- Fill a cairo context with a cairo surface
---@param cr cairo.Context
---@param surface cairo.Surface
const fill_context_with_surface = (cr, surface) ->
	--- If the source is not reset to what it was originally, drawing anything above
	--- the context will not show up (including using `wibox.layout.stack`)
	const original_source = cr::get_source()

	cr::set_source_surface(surface, 0, 0)
	cr::paint()

	cr::set_source(original_source)

	surface

--- Automatically generate a dynamic property (a getter and a setter function for a `gears.object`)
---@param object table
---@param property_name string The name of the property
---@return table object
const gen_property = (object, property_name) ->
	assert_param_type("gen_property", 1, "table",  object)
	assert_param_type("gen_property", 2, "string", property_name)

	object["get_#{property_name}"] = () =>
		@_private[property_name]

	object["set_#{property_name}"] = (value) =>
		@_private[property_name] = value
		@emit_signal("property::#{property_name}", value)
		@_private.force_redraw = true
		@emit_signal("widget::redraw_needed")

	object

--- Create a copy of a table while re-using the same metatable
---@generic T1
---@param tb table
---@param __type__ `T1`
---@return T1 copy_of_tb
const copy = (tb, __type__) ->
	assert_param_type("copy", 1, "table", tb)

	const copy_of_tb = { k, v for k, v in pairs(tb) }

	copy_of_tb.<> = tb.<>

	copy_of_tb

---@class surface_filters.common : wibox.widget.base
---@operator call: surface_filters.common
---@field widget wibox.widget|nil The wrapped widget
const surface_filters_common = {
	get_widget: () =>
		@_private.widget

	set_widget: (widget) =>
		const child_redraw_listener = @_private.child_redraw_listener

		if old_widget = @_private.widget
			old_widget::disconnect_signal("widget::redraw_needed", child_redraw_listener)
			for child in *old_widget.all_children
				child::disconnect_signal("widget::redraw_needed", child_redraw_listener)

		widget::connect_signal("widget::redraw_needed", child_redraw_listener)
		for child in *widget.all_children
			child::connect_signal("widget::redraw_needed", child_redraw_listener)

		wibox.widget.base.set_widget_common(@, widget)

	get_children: () =>
		{ @_private.widget }

	set_children: (children) =>
		@set_widget(children[1])

	draw: (context, cr, width, height) =>
		const child = @get_widget()

		if child == nil
			return

		if (not self._private.force_redraw) and (@_private.cached_surface?)
			fill_context_with_surface(cr, @_private.cached_surface)
			return

		const surface = if @on_draw?
			@on_draw(cr, width, height, child)
		else
			wibox.widget.draw_to_image_surface(child, width, height)

		@_private.force_redraw = false
		@_private.cached_surface = surface

		fill_context_with_surface(cr, surface)

	__name: "surface_filters.common"

	<call>: (cls, kwargs={}) ->
		const self = wibox.widget.base.make_widget(nil, cls.__name, { enable_properties: true })
			|> gears.table.crush(cls)

		@_private ??= {}

		@_private.child_redraw_listener = () ->
			@_private.force_redraw = true
			@emit_signal("widget::redraw_needed")

		if cls.parse_kwargs?
			cls.parse_kwargs(kwargs)

		for k, v in pairs(kwargs)
			@[k] = v

		@
}

---@class surface_filters.blur : surface_filters.common
---@field radius integer The blur radius
---@field dual_pass boolean If `true`, split the blurring process into two stages (creates a softer look)
export blur = with blur = copy(surface_filters_common, "surface_filters.blur")
	gen_property(blur, "radius")

	blur.__name = "surface_filters.blur"

	blur.on_draw = (cr, w, h, child) =>
		assert(@radius)

		const surface = wibox.widget.draw_to_image_surface(child, w, h)

		const surface_processed = if @dual_pass?
			const half = @radius / 2
			surface
				|> cairo_image_surface_create_blurred(math.ceil(half))
				|> cairo_image_surface_create_blurred(math.floor(half))
		else
			cairo_image_surface_create_blurred(surface, @radius)

		fill_context_with_surface(cr, surface_processed)

	blur.parse_kwargs = (kwargs) ->
		with kwargs
			.radius ??= 10
			.opacity ??= 1.0
			.dual_pass ??= false

---@class surface_filters.shadow : surface_filters.common
---@field radius integer The shadow radius
---@field dual_pass boolean If `true`, split the blurring process into two stages (creates a softer look)
export shadow = with shadow = copy(surface_filters_common)
	gen_property(shadow, "radius")

	shadow.__name = "surface_filters.shadow"

	shadow.on_draw = (cr, w, h, child) =>
		assert(@radius)

		const surface = wibox.widget.draw_to_image_surface(child, w, h)

		const surface_processed = if @dual_pass?
			const half = @radius / 2
			surface
				|> cairo_image_surface_create_shadow(math.ceil(half))
				|> cairo_image_surface_create_shadow(math.floor(half))
		else
			cairo_image_surface_create_shadow(surface, @radius)

		fill_context_with_surface(cr, surface_processed)

	shadow.parse_kwargs = (kwargs) ->
		with kwargs
			.radius ??= 10
			.opacity ??= 1.0
			.dual_pass ??= false
